use crate::block_br::{BasicBlockMap, BranchAnalyzer};
use crate::inst::Inst::*;
use crate::{inst::InstDecoder, optimizer::Optimizer};

pub unsafe fn prepass(addr: *const u32) -> BasicBlockMap {
    let mut opt = Optimizer::new();

    let mut pc = 0;

    loop {
        let inst = (*addr.byte_offset(pc)).to_le_bytes();
        let mut decoder = InstDecoder::new(inst.as_slice());
        let Ok(inst) = decoder.decode_inst() else {
            break;
        };

        opt.perform(inst);
        match &inst {
            // indirect jumps and exceptions
            Br { .. } | Blr { .. } | Ret { .. } | Udf { .. } | Svc { .. } => break,
            _ => (),
        }

        pc += 4;
    }

    let insts = opt.finalize();

    let mut br = BranchAnalyzer::new();

    br.perform_link(&insts, 0);
    br.finalize()
}

#[cfg(test)]
mod tests {
    use super::prepass;

    #[test]
    fn test() {
        let mem = [
            0xffu8, 0x43, 0x00, 0xd1, 0xff, 0x0f, 0x00, 0xb9, 0x28, 0x00, 0x80, 0x52, 0xe8, 0x0b,
            0x00, 0xb9, 0xff, 0x07, 0x00, 0xb9, 0x01, 0x00, 0x00, 0x14, 0xe8, 0x07, 0x40, 0xb9,
            0x08, 0x29, 0x00, 0x71, 0xe8, 0xb7, 0x9f, 0x1a, 0x68, 0x01, 0x00, 0x37, 0x01, 0x00,
            0x00, 0x14, 0xe9, 0x0b, 0x40, 0xb9, 0xe8, 0x0b, 0x40, 0xb9, 0x08, 0x01, 0x09, 0x0b,
            0xe8, 0x0b, 0x00, 0xb9, 0x01, 0x00, 0x00, 0x14, 0xe8, 0x07, 0x40, 0xb9, 0x08, 0x05,
            0x00, 0x11, 0xe8, 0x07, 0x00, 0xb9, 0xf3, 0xff, 0xff, 0x17, 0xe0, 0x0b, 0x40, 0xb9,
            0xff, 0x43, 0x00, 0x91, 0xc0, 0x03, 0x5f, 0xd6,
        ];

        let d = unsafe { prepass(mem.as_ptr().cast()) };

        println!("{d:?}");
    }
}
